tcp 编程中无论是服务端还是客户端 都需要考虑粘包和拆包机制

tcp是一个"流"协议，所谓流就是没用分界的一串数据，tcp底层并不了解上层业务数据的具体含义，所以在业务上认为一个完整的包可能会
被tcp拆分成多个包进行发送
例如数据包a,b
1 一次性收到了两个数据包 a,b包会在一起 被称为粘包
2 分两次收到两个独立数据包 a,b 没有发生粘包和拆包
3 分两次收到数据 第一次收到完整a包和部分b1包，第二次收到剩余b包b2
4 分两次收到数据 第一次收到部分a包a1 第二次收到剩余a2和完整b包
5 还有可能服务端tcp接收滑窗非常小，而数据包a,b非常大，可能会分多次才能完全接收a,b包 期间发生多次拆包


粘包和拆包 原因
1 应用程序write写入的字节大小大于套接口发送缓冲区大小
2 进行MSS 大小的TCP分段
3 以太网帧的payload大于MTU进行ip分片(这个与网卡有关 Maximum Transmission Unit 一种通信协议的某一层面上能通过的最大数据包大小)

由于底层tcp无法理解上层的业务数据，所以在底层是无法保证数据不被拆分和重组
需要通过上层应用协议栈设计来解决
1 消息定长 空位补空格
2 以特殊字符分隔(例如在尾部加换行符Netty 中LineBasedFrameDecoder)
3 将消息分为消息头和消息体，消息头中包含消息总长度
4 更复杂的应用层协议

本章介绍的是LineBasedFrameDecoder
其原理是依次遍历ByteBuf 中可读的字节，判断看是否有\n 或\r\n
如果有就以此作为结束标志
StringDecoder 将接收的对象转换为字符串
本例使用LineBasedFrameDecoder+StringDecoder 进行文本解码器

第5章包含解码器
DelimiterBasedFrameDecoder 自动完成以分隔符作为结束标志的消息解码
FixedLengthFrameDecoder  对定长消息的解码


























